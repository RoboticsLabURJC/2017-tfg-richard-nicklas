// Code generated by Icestudio 0.5.1w210224

`default_nettype none

//---- Top entity
module main #(
 parameter v1408f0 = 8,
 parameter vf998b8 = 104
) (
 input v3099bf,
 input ve9d9c7,
 input vbd3688,
 input v650200,
 input v8cc021,
 output [7:0] v9afc5b,
 output v92fed0,
 output v278cff,
 output v749246,
 output v6f32c9
);
 localparam p8 = v1408f0;
 localparam p9 = vf998b8;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:7] w6;
 wire w7;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire [0:7] w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire [0:7] w28;
 assign w0 = v3099bf;
 assign w1 = ve9d9c7;
 assign w2 = vbd3688;
 assign w3 = v650200;
 assign w4 = v8cc021;
 assign v92fed0 = w5;
 assign v9afc5b = w6;
 assign v6f32c9 = w7;
 assign w10 = v3099bf;
 assign w11 = v3099bf;
 assign w12 = ve9d9c7;
 assign w22 = v8cc021;
 assign v278cff = w23;
 assign v749246 = w24;
 assign w25 = ve9d9c7;
 assign w26 = vbd3688;
 assign w10 = w0;
 assign w11 = w0;
 assign w11 = w10;
 assign w12 = w1;
 assign w20 = w19;
 assign w21 = w19;
 assign w21 = w20;
 assign w22 = w4;
 assign w25 = w1;
 assign w25 = w12;
 assign w26 = w2;
 main_v107d31 v107d31 (
  .clk(w0),
  .btn1(w1),
  .rxd(w2),
  .btn2(w3),
  .MISO(w4),
  .txd(w5),
  .leds(w6),
  .SSBar(w7),
  .start(w14),
  .data_flash(w15),
  .busy_spi(w16),
  .flash_ok(w17),
  .ack(w18),
  .got_data_in(w27),
  .data_in(w28)
 );
 vc0b811 #(
  .v9e847c(p9)
 ) v5248ae (
  .v133291(w11),
  .veadd36(w25),
  .vdbee09(w26),
  .v11a4b0(w27),
  .v16f08f(w28)
 );
 v898907 #(
  .v980c02(p8)
 ) vc175f4 (
  .v962873(w10),
  .ve17a61(w12),
  .v0c3884(w13),
  .v141acd(w14),
  .v9841fd(w15),
  .v49c920(w16),
  .v03edbc(w17),
  .v7d3cb4(w18),
  .v48c7aa(w19),
  .v5ed28b(w20),
  .v31eb2a(w21),
  .vd421f3(w22),
  .vb1496e(w23),
  .v0e813c(w24)
 );
 v3e6c24 ve92202 (
  .v608bd9(w13)
 );
 v862d2a vce6671 (
  .v608bd9(w19)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module vc0b811 #(
 parameter v9e847c = 104
) (
 input v133291,
 input veadd36,
 input vdbee09,
 input v11a4b0,
 input [7:0] v16f08f,
 input va5e6d5,
 output v60312e,
 output vfe9854,
 output [7:0] ve5f816,
 output v1b4b60
);
 localparam p10 = v9e847c;
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 wire [0:7] w7;
 wire w8;
 wire w9;
 assign w0 = veadd36;
 assign w1 = vdbee09;
 assign w2 = v11a4b0;
 assign w3 = v16f08f;
 assign w4 = va5e6d5;
 assign v60312e = w5;
 assign vfe9854 = w6;
 assign ve5f816 = w7;
 assign v1b4b60 = w8;
 assign w9 = v133291;
 vc0b811_v461d1b #(
  .div(p10)
 ) v461d1b (
  .rst(w0),
  .rxd(w1),
  .wr(w2),
  .din(w3),
  .rd(w4),
  .txd(w5),
  .rdy(w6),
  .dout(w7),
  .valid(w8),
  .clk(w9)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module vc0b811_v461d1b #(
 parameter div = 0
) (
 input clk,
 input rst,
 input rxd,
 input wr,
 input [7:0] din,
 input rd,
 output txd,
 output rdy,
 output [7:0] dout,
 output valid
);
 	//parameter div = 234; // 27MHz , 115200 baud , div=234
 	//parameter div = 104; // 12MHz , 115200 baud , div=104
 	
 	reg[31:0] count;
 	reg[7:0] data; 
 	
 	always @(posedge clk or posedge rst) begin
 		if(rst)	data = 0;
 		else if(wr) begin
 				data = din;
 		end
 	end
 	
 	
 	wire tick;
 	
 	reg[3:0] state,n_state;
 	parameter s0 = 0;
 	parameter s1 = 1;
 	parameter s2 = 2;
 	parameter s3 = 3;
 	parameter s4 = 4;
 	parameter s5 = 5;
 	parameter s6 = 6;
 	parameter s7 = 7;
 	parameter s8 = 8;
 	parameter s9 = 9;
 	
 	
 	
 	
 	always @(posedge clk or posedge rst) begin
 		if(rst)	begin
 			count <= 0;
 		end
 		else	begin
 			if(tick)	count <= 0;
 			else	count <= count + 1;
 		end
 	end
 	assign tick = (count == div) | (wr & (state==0));
 	
 	
 	always @(posedge clk or posedge rst) begin
 		if(rst)	state <= 0;
 		else if(tick) state <= n_state;
 	end
 	
 	always @(state or wr) begin
 		if(state == 0) begin
 			if(wr)	n_state <= 1;
 			else	n_state <= 0;
 		end
 		else if(state < 10)	n_state <= state + 1;
 		else n_state <= 0;
 	end
 	
 	always @(*) begin
 		case(state)
 			4'h0: txd <= 1;
 			4'h1: txd <= 0;
 			4'h2: txd <= data[0];
 			4'h3: txd <= data[1];
 			4'h4: txd <= data[2];
 			4'h5: txd <= data[3];
 			4'h6: txd <= data[4];
 			4'h7: txd <= data[5];
 			4'h8: txd <= data[6];
 			4'h9: txd <= data[7];
 			default: txd <= 1;
 		endcase
 	end
 	
 	assign rdy = (state == s0);
 	
 	
 	////////////////////RX Section////////////////////////////
 	reg[15:0] rx_baud_count;
 	wire rx_tick;
 	reg rx_baudgen_rst;
 	always @(posedge clk or posedge rst) begin
 		if(rst) rx_baud_count <= 0;
 		else
 			if(rx_baudgen_rst | (rx_baud_count == div))	rx_baud_count <= 0;
 			else rx_baud_count <= rx_baud_count + 1;
 	end
 	assign rx_tick = (rx_baud_count == div/2);
 	
 	reg rx_shift;
 	reg[3:0] rx_bits_rxed,rx_bits_next_rxed;
 	reg[3:0] rx_state,rx_next_state;
 	always @(posedge clk or posedge rst) begin
 		if(rst)
 			dout <= 0;
 		else
 			if(rx_shift)	dout <= { rxd, dout[7:1] };
 	end
 	
 	
 	
 	reg next_valid;
 	
 	always @(posedge clk or posedge rst) begin
 		if(rst) 
 			begin
 				rx_state <= 0;
 				rx_bits_rxed <= 0;
 				
 			end
 		else
 			begin
 				rx_bits_rxed <= rx_bits_next_rxed;
 				rx_state <= rx_next_state;
 				
 			end
 	end
 	
 	always @(*) begin
 		rx_next_state <= rx_state;
 		rx_baudgen_rst <= 0;
 		rx_bits_next_rxed <= rx_bits_rxed;
 		rx_shift <= 0;
 		valid <= 0;
 		case(rx_state)
 			4'h0: begin
 						if(rxd==0)	rx_next_state <= 1;
 					end
 			4'h1: begin
 						rx_baudgen_rst <= 1;
 						rx_bits_next_rxed <= 0;
 						rx_next_state <= 2;
 					end
 			4'h2: begin
 						if(rx_tick) rx_next_state <= 3;
 					end
 			4'h3: begin
 						rx_shift <= 1;
 						rx_bits_next_rxed <= rx_bits_rxed + 1;
 						if(rx_bits_rxed < 8)	rx_next_state <= 2;
 						else	rx_next_state <= 4;
 					end
 			4'h4: begin
 						if(rx_tick) rx_next_state <= 5;
 					end
 			4'h5: begin
 						valid <= 1;
 						if(rd)	rx_next_state <= 0;
 					end
 			endcase
 	end
 
endmodule
//---- Top entity
module v898907 #(
 parameter v980c02 = 8
) (
 input v962873,
 input ve17a61,
 input v0c3884,
 input v141acd,
 input [7:0] v06c25a,
 input v7d3cb4,
 input v48c7aa,
 input v5ed28b,
 input v31eb2a,
 input vd421f3,
 output [7:0] v9841fd,
 output v49c920,
 output v03edbc,
 output vb1496e,
 output v4cf0a5,
 output v0e813c
);
 localparam p10 = v980c02;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:7] w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w11;
 wire [0:7] w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 assign w0 = v962873;
 assign w1 = ve17a61;
 assign w2 = v0c3884;
 assign w3 = v141acd;
 assign w4 = v06c25a;
 assign w5 = v7d3cb4;
 assign w6 = v48c7aa;
 assign w7 = v5ed28b;
 assign w8 = v31eb2a;
 assign w9 = vd421f3;
 assign v49c920 = w11;
 assign v9841fd = w12;
 assign v0e813c = w13;
 assign v4cf0a5 = w14;
 assign vb1496e = w15;
 assign v03edbc = w16;
 v898907_vf6a642 #(
  .DATA_W(p10)
 ) vf6a642 (
  .clk_i(w0),
  .rst_i(w1),
  .ena_i(w2),
  .start_i(w3),
  .tx_i(w4),
  .ack_i(w5),
  .cpo_i(w6),
  .dord_i(w7),
  .cpha_i(w8),
  .miso_i(w9),
  .busy_o(w11),
  .rx_o(w12),
  .mosi_o(w13),
  .mosi_en_o(w14),
  .sclk_o(w15),
  .irq_o(w16)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v898907_vf6a642 #(
 parameter DATA_W = 0
) (
 input clk_i,
 input rst_i,
 input ena_i,
 input start_i,
 input [7:0] tx_i,
 input ack_i,
 input cpo_i,
 input dord_i,
 input cpha_i,
 input miso_i,
 output [7:0] rx_o,
 output busy_o,
 output irq_o,
 output sclk_o,
 output mosi_en_o,
 output mosi_o
);
 /***********************************************************************
 
   SPI Master
 
   This file is part FPGA Libre project http://fpgalibre.sf.net/
 
   Description:
   Configurable Master Serial Protocol Interface controller.
   This is different than SPI_controller:
   - Modes can be configured with signals, not just generics.
   - The SS logic is left to the upper level.
   - We always return to IDLE before transmitting again.
   - IMPORTANT! assumes that start_i resets the ena_i generator. In
     this way start_i can last 1 clock cycle (no need to wait for
     busy_o to become 1).
 
   To Do:
   -
 
   Author:
     - Salvador E. Tropea, salvador en inti gob ar
 
 ------------------------------------------------------------------------------
 
  Copyright (c) 2017 Salvador E. Tropea <salvador en inti gob ar>
  Copyright (c) 2017 Instituto Nacional de Tecnolog√≠a Industrial
 
  Distributed under the GPL v2 or newer license
 
 ------------------------------------------------------------------------------
 
  Design unit:      SPI_Master(RTL) (Entity and architecture)
  File name:        spi_master.v
  Note:             None
  Limitations:      None known
  Errors:           None known
  Library:          None
  Dependencies:     IEEE.std_logic_1164
                    IEEE.numeric_std
  Target FPGA:
  Language:         Verilog
  Wishbone:         None
  Synthesis tools:
  Simulation tools: GHDL [Sokcho edition] (0.2x)
  Text editor:      SETEdit 0.5.x
 
 ***********************************************************************/
 localparam integer CNT_BITS=$clog2(DATA_W);
 localparam IDLE=0, LEADING_SCLK=1, TRAILING_SCLK=2, STOP=3; // state_t
 
 reg  [DATA_W-1:0] reg_r=0;
 reg  sclk_r=0;
 reg  [CNT_BITS-1:0] bit_cnt=0;
 reg  [1:0] state=IDLE; // states for shifter_FSM.
 reg  miso_r; // Sampled MISO
 
 always @(posedge clk_i)
 begin : shifter_FSM
   if (rst_i)
      begin
      state  <= IDLE;
      sclk_r <= 0;
      irq_o  <= 0;
      end
   else
      begin
      if (ack_i)
         irq_o <= 0;
      case (state)
         IDLE:
           if (start_i) // init transaction
              begin
              state   <= LEADING_SCLK;
              reg_r   <= tx_i;
              bit_cnt <= 0;
              end
         LEADING_SCLK:
           if (ena_i)
              begin
              state  <= TRAILING_SCLK;
              sclk_r <= !sclk_r;
              if (!cpha_i) // Leading sample
                 miso_r <= miso_i;
              end
         TRAILING_SCLK:
           if (ena_i)
              begin
              sclk_r <= !sclk_r;
              if (bit_cnt==DATA_W-1)
                 begin
                 state <= STOP;
                 bit_cnt <= 0;
                 end
              else
                 begin
                 state <= LEADING_SCLK;
                 bit_cnt <= bit_cnt+1;
                 end
              if (cpha_i) // Leading sample
                 miso_r <= miso_i;
              end
         default: // STOP
           // Maintain the last bit for half the clock to finish
           // If we don't do it we could violate the slave hold time
           if (ena_i)
              begin
              irq_o <= 1;
              state <= IDLE;
              end
      endcase
      // Shift in cases
      if (ena_i)
         if (  (state==TRAILING_SCLK && !cpha_i) ||
             (((state==LEADING_SCLK && bit_cnt) || state==STOP) && cpha_i))
            begin
            // Shift
            if (dord_i)
               // Right
               reg_r <= {miso_r,reg_r[DATA_W-1:1]};
            else
               // Left
               reg_r <= {reg_r[DATA_W-2:0],miso_r};
            end
      end // !rst_i
 end // shifter_FSM
 
 // The FSM generates CPOL=0, if CPOL is 1 we just invert
 assign sclk_o=sclk_r^cpol_i;
 // MOSI takes the LSB or MSB according to DORD
 assign mosi_o=dord_i ? reg_r[0] : reg_r[DATA_W-1];
 assign mosi_en_o=state!=IDLE;
 assign rx_o=reg_r;
 assign busy_o=state!=IDLE;
 
endmodule
//---- Top entity
module v3e6c24 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 v3e6c24_v68c173 v68c173 (
  .v(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- Bit 1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Assign 1 to the output wire
/*-------------------------------------------------*/

module v3e6c24_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule
//---- Top entity
module v862d2a (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 v862d2a_v68c173 v68c173 (
  .v(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- Bit 0  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Assign 0 to the output wire
/*-------------------------------------------------*/

module v862d2a_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule

module main_v107d31 (
 input clk,
 input btn1,
 input rxd,
 input btn2,
 input MISO,
 input [7:0] data_flash,
 input busy_spi,
 input flash_ok,
 input [7:0] data_out,
 input got_data_out,
 input new_byte,
 output txd,
 output [7:0] leds,
 output SCLK,
 output MOSI,
 output SSBar,
 output start,
 output [7:0] data_spi,
 output ack,
 output got_data_in,
 output [7:0] data_in,
 output ready_in
);
 //////////////////////////////////////////////////////////////////////////////////
 // Company: Ridotech
 // Engineer: Juan Manuel Rico
 // 
 // Create Date:    19:07:39 30/05/2017 
 // Design Name:    Pruebas Flash-SPI
 // Module Name:    top 
 // Project Name:   Cold/Warn boot desde FPGA.
 // Target Devices: 
 // Tool versions: 
 // Description:  Pruebas para crear un m√≥dulo SPI que pueda acceder al chip flash 
 //               desde la propia FPGA, poder modificar el applet de la memoria y
 //               poder utilizarla para guardar informaci√≥n en la misma. 
 //
 // Dependencies: "SPI_master" (del proyecto Lattuino) y "uart" de otro proyecto.
 //               
 // Revision: 
 // Revision 0.01 - File Created
 // Revision 0.02 - Se a√±aden comentarios explicativos.
 //
 // Additional Comments: 
 // TODO - Hacer esquema gr√°fico del sistema.
 // 2017-09-03 - Las √∫ltimas pruebas se basan en el comportamiento de la UART.
 //              Para hacerlas hay que pulsar el bot√≥n 1 de la placa y activar los m√≥dulos.
 //              Cualquier tecla pulsada que no sea un n√∫mero debe dar un eco.
 //              Al pulsar los n√∫meros del 1 al 9 van cambiando los leds y la secuencia de
 //              acceso a la flash.
 //              Al pulsar repetidamente el n√∫mero 6 deben ir apareciendo en la consola
 //              los bytes dados del ID de la flash. (los dados por "iceprog -t").
 //
 //////////////////////////////////////////////////////////////////////////////////
 // 12MHz clock with 115200 baud
 
 	 reg start = 0;         	// Registro que mantiene la se√±al de start para el m√≥dulo SPI.
 	 wire flash_ok;             // Conexi√≥n con la interrupci√≥n del m√≥dulo SPI indicando que el registro con los datos est√° completo.
                                 // En nuestro caso indica que el registro de 8 bits con los datos de la flash est√° lista.
 	 wire ack;                  // Conexi√≥n con la se√±al de reconocimiento de lectura del registro de datos de la flash.
      wire busy_spi;             // M√≥dulo SPI ocupado con una transferencia de datos.
 	 reg[7:0] data_spi;         // Registro con los datos que se quieren transmitir por el m√≥dulo SPI.
      reg[7:0] data_flash;       // Registro con los datos que vienen del m√≥dulo SPI desde la flash.
  
 	reg[7:0] data_in, data_out;  // Registros de la UART, registro de entrada (el que queremos enviar al PC) y salida al m√≥dulo (el que recibimos).
 	wire got_data_in;            // Se√±al de que hay un dato preparado para enviar (el que leemos desde la flash o el que hacemos eco).
     wire got_data_out;           // Se√±al de que hay un dato preparado para leer (viene de una consola, teclado).
     wire new_byte;               // Se√±al para indicar que puede usar el registro para actualizarlo con un nuevo dato leido.
     wire ready_in;               // Se√±al para indicar que se complet√≥ la transferencia de escritura por UART.
 
 	always @(posedge clk) begin
 		// La se√±al start activa solo dura un ciclo de reloj.
 		if (start) start = 1'b0;
 
 		// La se√±al ack activa solo dura un ciclo de reloj.
 		if (ack) ack = 1'b0;
 		
         // Si el byte de la uart ya ha sido enviado se prepara para el siguiente para no reenviar el mismo.
         if (got_data_in) got_data_in = 1'b0;
 
 		// En cuanto est√© listo el byte de lectura de la flash se guarda y se prepara para enviar por la UART.
 		if (flash_ok) begin
 			data_in <= data_flash;
      		if (ready_in) got_data_in <= 1'b1;
             ack <= 1'b1;         // Ya est√° guardado, toma el siguiente (ack debe poner el flash_ok a cero seg√∫n S.E.Tropea).
 			leds[7] <= ~leds[7]; // Debug - Se hace parpadear el led m√°s significativo.
 		end
 
         // Seg√∫n se tenga en el puerto serie un valor (data_out del m√≥dulo UART) se realiza una acci√≥n distinta.
         // NOTA: Cambiar este conjunto de "if" por "switch..case".
         // NOTA2: Esto debe ser sustituido por una m√°quina de estados.
  
         // Si hay un valor v√°lido para leer del m√≥dulo UART...
         if (got_data_out) begin
             
             // Si son n√∫meros se realiza la secuencia de lectura.  
 			if (data_out == "1") begin
 				SSBar <= 1'b0;  			// Activar el protocolo SPI en el esclavo (flash).
 		        leds[0] <= 1'b1;
 			end
 			else if (data_out == "2") begin
 				data_spi <= 8'hAB;          // Enviar por SPI el comando para despertar el chip flash.
 		        if (!busy_spi)            
 		            start <= 1'b1;
 		        leds[1] <= 1'b1;
 			end
 			else if (data_out == "3") begin
 				SSBar <= 1'b1;	            // Desactivamos el esclavo una vez despierto (seg√∫n sketch de S.E.Tropea para Lattuino).
 		        leds[2] <= 1'b1;
 			end
 			else if (data_out == "4") begin
 				SSBar <= 1'b0;              // Activamos de nuevo el esclavo.
 		        leds[3] <= 1'b1;			
 			end
 			else if (data_out == "5") begin
 		        leds[4] <= 1'b1;            // No se hace nada, solo enciende un led como debug.
 			end
 		    else if (data_out == "6") begin
 				data_spi <= 8'h9F;          // Se env√≠a el comando para leer el ID de la memoria.
                                             // En la primera pulsaci√≥n se recibir√° un FF, en las siguientes los valores de la
                                             // ID que transmita la memoria (los valores obtenidos mediante "iceprog -t").
 		        if (!busy_spi) 
 		            start <= 1'b1;
 		        leds[5] <= 1'b1;
 			end
 		    else if (data_out == "7") begin
 		        leds[6] <= 1'b1;            // No se hace nada, solo enciende un led como debug.
 			end
 		    else if (data_out == "8") begin
 		        leds[7] <= ~leds[7];		// No se hace nada, solo hace parpadear un led como debug.
 			end
 		    else if (data_out == "9") begin 
 		        leds <= 8'h00;              // No se hace nada, solo borra los leds.
 			end
 			else begin
                 // Si se pulsa cualquier otra tecla hace un eco de ella.
 				data_in <= data_out;
 		 		got_data_in <= got_data_out;
 			end
          
             // Se le dice a la UART que ya puede leer un nuevo byte.
             new_byte = 1'b1;           
         end
 	end
endmodule
